package com.example.novelonline.fragments // Ensure this matches your project's package

import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.EditText
import android.widget.LinearLayout
import android.widget.TextView
import androidx.fragment.app.Fragment
import androidx.navigation.fragment.findNavController // For Navigation Component
import com.example.novelonline.R
import com.example.novelonline.databinding.FragmentWriteChaptersBinding // This will be generated by View Binding

class WriteChaptersFragment : Fragment() {

    // Declare a binding object
    private var _binding: FragmentWriteChaptersBinding? = null
    // This property is only valid between onCreateView and onDestroyView.
    private val binding get() = _binding!!

    // Declare views
    private lateinit var backArrow: TextView
    private lateinit var wordCountTextView: TextView
    private lateinit var nextButton: Button
    private lateinit var chapterTitleEditText: EditText
    private lateinit var mainTextEditText: EditText
    private lateinit var addAuthorsThoughtsSection: LinearLayout
    private lateinit var boldButton: TextView
    private lateinit var italicButton: TextView
    private lateinit var saveButton: TextView
    private lateinit var undoButton: TextView
    private lateinit var redoButton: TextView

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout using View Binding
        _binding = FragmentWriteChaptersBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Initialize views using the binding object
        backArrow = binding.backArrow
        wordCountTextView = binding.wordCountTextView
        nextButton = binding.nextButton
        chapterTitleEditText = binding.chapterTitleEditText
        mainTextEditText = binding.mainTextEditText
        addAuthorsThoughtsSection = binding.addAuthorsThoughtsSection
        boldButton = binding.boldButton
        italicButton = binding.italicButton
        saveButton = binding.saveButton
        undoButton = binding.undoButton
        redoButton = binding.redoButton

        // --- Set up click listeners ---

        // Back arrow
        backArrow.setOnClickListener {
            findNavController().navigateUp() // Navigate back
        }

        // Next button
        nextButton.setOnClickListener {
            // TODO: Implement logic for "Next" button click
            // e.g., save chapter, navigate to next step (e.g., publish options)
            val chapterTitle = chapterTitleEditText.text.toString()
            val mainText = mainTextEditText.text.toString()
            // Perform actions with chapterTitle and mainText
        }

        // Add Author's Thoughts section
        addAuthorsThoughtsSection.setOnClickListener {
            // TODO: Implement logic for "Add Author's Thoughts"
            // e.g., open a dialog or navigate to a new screen for author's notes
        }

        // Bottom toolbar buttons
        boldButton.setOnClickListener {
            // TODO: Implement bold formatting logic
            // This would typically involve modifying the SpannableString in mainTextEditText
        }
        italicButton.setOnClickListener {
            // TODO: Implement italic formatting logic
        }
        saveButton.setOnClickListener {
            // TODO: Implement save chapter logic
            // You might want to save chapterTitleEditText.text.toString() and mainTextEditText.text.toString()
        }
        undoButton.setOnClickListener {
            // TODO: Implement undo logic (requires managing text history)
        }
        redoButton.setOnClickListener {
            // TODO: Implement redo logic (requires managing text history)
        }

        // --- TextWatcher for word count ---
        mainTextEditText.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
                // Not needed for this functionality
            }

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                // Not needed for this functionality
            }

            override fun afterTextChanged(s: Editable?) {
                val text = s?.toString() ?: ""
                val words = text.split("\\s+".toRegex()).filter { it.isNotBlank() } // Split by whitespace and filter empty strings
                val wordCount = words.size
                wordCountTextView.text = "$wordCount Word"
            }
        })
    }

    override fun onDestroyView() {
        super.onDestroyView()
        // Clear the binding object to avoid memory leaks
        _binding = null
    }

    // Optional: A factory method to create instances of the fragment
    companion object {
        fun newInstance() = WriteChaptersFragment()
    }
}